- phút 19: sử dụng useReduce khi cần quản lý nhiều state.
- phút 41: không nên sử dụng dom.getElementById trong React component vì nó đang can thiệp trực tiếp vô DOM, trong khi đó thì React đang dùng DOM giả. Giải pháp là dùng useRef.
- phút 48: callback của useLayoutEffect được gọi trước useEffect, nó được gọi ở giai đoạn render, trong khi đó useLayoutEffect được gọi ở giai đoạn sau của quá trình render, khi mọi thứ đã render xong rồi.
- phút 52 -> 60: giới thiệu hook useImperativeHandle, quá thú vị. Trong bài tác giả sử dụng mô hình đơn giản gồm 2 component lồng nhau. Component cha có một cái ref truyền vào trong component con. Khi đó component con cần phải được init bằng forwadRef để có thể truy xuất được cái ref mà component cha tạo. Sau đó trong component con sử dụng useImperativeHandle kết hợp với ref, đê tạo thêm method cho ref, định nghĩa luôn nội dung menthod đó cho ref. Ví dụ trong bài là định nghĩa ra hàm alterToggle. Component cha sau đó có thể gọi ref.alterToggle để kích hoạt chức năng toggle của component con. Cái này giống như cung cấp một hàm sự kiện để component cha gọi điều khiển component con. Nếu trước đây thì mình sẽ đơn giản là chuyền một state xuống cho component con cùng với hàm set state đi kèm, khi đó thì cả component cha và con đều access vô được nội dung của state và có thể gọi hàm set state để toggle cái state, dù là ở component con hay cha. Nhưng với cách đó thì mình sẽ phải truyền state, với cách này thì không cần truyền gì cả, component cha chỉ cần tạo ref là dùng được.... cái này mới
- phút 60 -> 69: nói về dùng createContext, useContext để tạo ra một nơi chia sẻ state giữa các component trong một tree với nhau. Ví dụ của tác giả là một component cha với 2 component con, và truyền state vào từ cha xuống các con. Với việc đổi sang dùng context thì không cần phải truyền state từ trên xuống như vậy nữa, mà mỗi component con có thể sử dụng useContext để access state trong đó. Nhưng trước hết thì phải dùng createContext ở componnet cha để tạo ra context cho bên dưới mấy đứa con dùng.
- phút 69 -> 79: nói về sử dụng useMemo, tác giả đề ra tình huống khi một component có 2 cái state, một cái được tính toán phức tạp bởi một hàm đặt trong template và một state đơn giản, khi user tác động đến state đơn giản sẽ làm component render lại và dẫn đến phải gọi gọi hàm tính toán phức tạp cho state đầu tiên. Nếu ta wrap cái hàm tính toán phức tạp bằng useMemo rồi sau đó set dependencies của useMemo bằng state thứ nhất, thì cho dù state thứ hai có thay đổi thế nào đi nữa thì hàm tính toán sẽ không được gọi tính toán lại, trừ khi state thứ nhất bị thay đổi.
